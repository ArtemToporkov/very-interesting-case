# Файл: ai_request_processor.py
# Содержимое:
import requests
import json


class AiRequestProcessor:
    def __init__(self, base_url: str):
        self.base_url = base_url

    def process_query(self, query: str) -> dict:
        payload = {"text": query}
        try:
            response = requests.post(self.base_url, json=payload)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            print(f"Ошибка при обращении к Rasa NLU API: {e}")
            raise



================================================================================

# Файл: database.py
# Содержимое:
import psycopg2
from psycopg2 import sql
from psycopg2.extras import DictCursor


class Database:
    def __init__(self, dbname, user, password, host="localhost", port="5432"):
        """Инициализация подключения к базе данных."""
        self.conn = None
        self.cursor = None
        try:
            self.conn = psycopg2.connect(
                dbname=dbname,
                user=user,
                password=password,
                host=host,
                port=port
            )
            # Используем DictCursor для получения результатов в виде словаря
            self.cursor = self.conn.cursor(cursor_factory=DictCursor)
            print("Подключение к базе данных успешно установлено.")
        except Exception as e:
            print(f"Ошибка подключения к базе данных: {e}")

    def execute_query(self, query, params=None, fetch=False):
        """Выполняет SQL-запрос и возвращает результат (если fetch=True)."""
        try:
            self.cursor.execute(query, params)
            if fetch:
                return self.cursor.fetchall()
            self.conn.commit()
        except Exception as e:
            self.conn.rollback()
            print(f"Ошибка выполнения запроса: {e}")
            return None

    def close(self):
        """Закрывает соединение с базой данных."""
        if self.cursor:
            self.cursor.close()
        if self.conn:
            self.conn.close()
        print("Соединение с базой данных закрыто.")

    def __del__(self):
        """Деструктор - автоматически закрывает соединение при удалении объекта."""
        self.close()

================================================================================

# Файл: database_query_parser.py
# Содержимое:
# Файл: database_query_parser.py
import datetime
from psycopg2 import sql

# Словарь для преобразования названий месяцев и их форм в номера
MONTH_NAME_TO_NUMBER = {
    "январь": 1, "января": 1, "январе": 1,
    "февраль": 2, "февраля": 2, "феврале": 2,
    "март": 3, "марта": 3, "марте": 3,
    "апрель": 4, "апреля": 4, "апреле": 4,
    "май": 5, "мая": 5, "мае": 5,
    "июнь": 6, "июня": 6, "июне": 6,
    "июль": 7, "июля": 7, "июле": 7,
    "август": 8, "августа": 8, "августе": 8,
    "сентябрь": 9, "сентября": 9, "сентябре": 9,
    "октябрь": 10, "октября": 10, "октябре": 10,
    "ноябрь": 11, "ноября": 11, "ноябре": 11,
    "декабрь": 12, "декабря": 12, "декабре": 12,
}


class DbQueryParser:
    @staticmethod
    def parse(data: dict):
        intent_name = data.get("intent", {}).get("name")
        if not intent_name:
            raise ValueError("Intent name is missing in NLU data")

        match intent_name:
            case "search_person":
                # Этот метод все еще возвращает строку, хорошо бы переделать
                query_str = DbQueryParser.search_person_str(data)
                return query_str, None  # Возвращаем как кортеж для единообразия
            case "search_event":
                return DbQueryParser.search_event(data)  # ИЗМЕНЕНО
            case "find_birthday":
                return DbQueryParser.find_birthday(data)
            case "check_task":
                return DbQueryParser.check_task(data)
        raise ValueError(f"Неизвестный интент: {intent_name}")

    @staticmethod
    def search_person_str(data: dict) -> str:
        for entity in data.get('entities', []):
            if entity.get('entity') == 'name':
                # ОСТОРОЖНО: SQL-инъекция! Этот метод должен быть переписан с использованием параметризации.
                return f'''
                    SELECT 
                        'PersonInfo',
                        emp."Surname", 
                        emp."Name", 
                        emp."Father", 
                        emp."Birthday", 
                        emp."FirstDay", 
                        lng."Name" as "LanguageName", 
                        rnk."Status" as "RankStatus",
                        prj."Name" as "ProjectName",
                        dprt."Name" as "DepartmentName",
                        emp."Contacts"
                    FROM "Employees" as emp
                    LEFT JOIN "Languages" as lng ON lng."Language_Id"=emp."LanguageId"
                    LEFT JOIN "Rank" as rnk ON rnk."Rank_Id" = emp."RankId"
                    LEFT JOIN "Project" as prj ON prj."Project_Id"=emp."ProjectId"
                    LEFT JOIN "Department" as dprt ON dprt."Department_Id"=emp."DepartmentId"
                    WHERE emp."Name" ILIKE '%{entity['value']}%' OR emp."Surname" ILIKE '%{entity['value']}%'
                    LIMIT 1;
                    '''
        raise ValueError("Сущность 'name' не найдена для search_person")

    @staticmethod
    def _parse_event_date_entity(date_entity_value: str) -> tuple[
        datetime.date | None, datetime.date | None, str | None]:
        """
        Парсит значение сущности 'date' для событий.
        Возвращает (start_date, end_date, special_condition_sql)
        special_condition_sql используется для "сегодня", "завтра".
        end_date используется для диапазонов типа "на этой неделе", "в этом месяце".
        """
        date_lower = date_entity_value.lower()
        today = datetime.date.today()

        if date_lower == "сегодня":
            return today, None, sql.SQL('ev."Begin"::date = CURRENT_DATE')
        if date_lower == "завтра":
            tomorrow = today + datetime.timedelta(days=1)
            return tomorrow, None, sql.SQL('ev."Begin"::date = CURRENT_DATE + INTERVAL \'1 day\'')

        if "на эт" in date_lower and "недел" in date_lower:  # "на этой неделе"
            start_of_week = today - datetime.timedelta(days=today.weekday())
            end_of_week = start_of_week + datetime.timedelta(days=6)
            return start_of_week, end_of_week, None

        if "в эт" in date_lower and "месяц" in date_lower:  # "в этом месяце"
            start_of_month = today.replace(day=1)
            next_month = start_of_month.replace(month=start_of_month.month % 12 + 1, day=1)
            if start_of_month.month == 12:  # Обработка декабря
                next_month = start_of_month.replace(year=start_of_month.year + 1, month=1, day=1)
            end_of_month = next_month - datetime.timedelta(days=1)
            return start_of_month, end_of_month, None

        # Попытка распарсить месяц типа "в июне"
        for month_name, month_number in MONTH_NAME_TO_NUMBER.items():
            if month_name in date_lower:
                year_to_use = today.year  # По умолчанию текущий год
                # Можно добавить логику для "в июне следующего года" если нужно
                start_of_month = datetime.date(year_to_use, month_number, 1)
                next_month_day_one = start_of_month.replace(month=start_of_month.month % 12 + 1, day=1)
                if start_of_month.month == 12:
                    next_month_day_one = start_of_month.replace(year=start_of_month.year + 1, month=1, day=1)
                end_of_month = next_month_day_one - datetime.timedelta(days=1)
                return start_of_month, end_of_month, None

        # Попытка распарсить конкретную дату "DD.MM.YYYY" или "DD MMMM"
        # Это очень упрощенный парсер, для более надежного нужен Duckling или regex
        try:
            # Попытка "25 мая", "10 июня"
            parts = date_lower.split()
            if len(parts) == 2 and parts[0].isdigit():
                day = int(parts[0])
                month_str = parts[1]
                month_num = None
                for mn, mnum in MONTH_NAME_TO_NUMBER.items():
                    if mn.startswith(month_str):  # Ищем по началу слова
                        month_num = mnum
                        break
                if month_num:
                    parsed_date = datetime.date(today.year, month_num, day)
                    return parsed_date, None, None  # Только начальная дата, без диапазона
        except (ValueError, IndexError):
            pass

        try:
            # Попытка "DD.MM.YYYY" или "DD.MM"
            # Это место требует более надежного парсинга дат
            parsed_date = None
            if '.' in date_entity_value:
                date_parts = date_entity_value.split('.')
                if len(date_parts) == 2:  # DD.MM
                    parsed_date = datetime.datetime.strptime(f"{date_parts[0]}.{date_parts[1]}.{today.year}",
                                                             "%d.%m.%Y").date()
                elif len(date_parts) == 3:  # DD.MM.YYYY
                    parsed_date = datetime.datetime.strptime(date_entity_value, "%d.%m.%Y").date()
            if parsed_date:
                return parsed_date, None, None  # Только начальная дата
        except ValueError:
            print(f"Warning: Could not parse date string '{date_entity_value}' for event date.")

        return None, None, None

    @staticmethod
    def search_event(data: dict):
        entities = DbQueryParser._entities_to_dict(data.get('entities', []))
        select_fields = [
            sql.SQL('ev."Name" AS event_name'),
            sql.SQL('ev."Begin" AS event_begin'),
            sql.SQL('ev."Duration" AS event_duration'),
            sql.SQL('cat."Name" AS category_name'),
            sql.SQL('ev."Descri..." AS event_description'),  # В схеме "Descri..."
            sql.SQL('emp."Name" AS organizer_name'),  # Если EmployeeId в Event это организатор
            sql.SQL('emp."Surname" AS organizer_surname')
        ]
        from_table = sql.SQL('FROM "Event" AS ev')  # Таблица Event, согласно схеме
        joins = [
            sql.SQL('LEFT JOIN "Categories" AS cat ON cat."Category_Id" = ev."CategoryId"'),
            sql.SQL('LEFT JOIN "Employees" AS emp ON emp."Employee_Id" = ev."EmployeeId"')
            # Предполагаем, что EmployeeId в Event - это ID организатора/ответственного
        ]
        where_clauses = []
        params = []

        if 'event_name' in entities:
            where_clauses.append(sql.SQL('ev."Name" ILIKE %s'))
            params.append(f"%{entities['event_name'][0]}%")

        if 'event_category' in entities:
            where_clauses.append(sql.SQL('cat."Name" ILIKE %s'))
            params.append(f"%{entities['event_category'][0]}%")

        if 'organizer' in entities:  # Если ищем по имени организатора
            name_val = entities['organizer'][0]
            if ' ' in name_val:
                parts = name_val.split(' ', 1)
                where_clauses.append(sql.SQL(
                    '((emp."Name" ILIKE %s AND emp."Surname" ILIKE %s) OR (emp."Name" ILIKE %s AND emp."Surname" ILIKE %s))'
                ))
                params.extend([f"%{parts[0]}%", f"%{parts[1]}%", f"%{parts[1]}%", f"%{parts[0]}%"])
            else:
                where_clauses.append(sql.SQL('(emp."Name" ILIKE %s OR emp."Surname" ILIKE %s)'))
                params.extend([f"%{name_val}%", f"%{name_val}%"])

        # Обработка сущности 'date'
        if 'date' in entities:
            # NLU может вернуть несколько дат, если текст содержит диапазон или несколько упоминаний
            # Для простоты возьмем первую сущность 'date'
            date_val = entities['date'][0]
            start_date, end_date, special_sql_cond = DbQueryParser._parse_event_date_entity(date_val)

            if special_sql_cond:
                where_clauses.append(special_sql_cond)
            elif start_date and end_date:  # Диапазон дат (напр. "на этой неделе")
                where_clauses.append(sql.SQL('ev."Begin"::date >= %s AND ev."Begin"::date <= %s'))
                params.extend([start_date, end_date])
            elif start_date:  # Конкретная дата или начало диапазона (напр. "25 мая")
                where_clauses.append(sql.SQL('ev."Begin"::date = %s'))
                params.append(start_date)

        # Фильтрация по местоположению ('location') не реализована, т.к. в таблице Event нет такого поля.
        # Если 'location' это, например, название комнаты из отдельной таблицы, нужен будет доп. JOIN.
        if 'location' in entities:
            print(
                f"Warning: Event location filtering is not directly supported by 'Event' table schema. Entity: {entities['location'][0]}")

        # Если нет никаких условий, запрос может вернуть слишком много данных.
        # Можно добавить условие по умолчанию, например, показывать события на ближайшую неделю,
        # или требовать хотя бы одно условие. Пока оставим так.
        if not where_clauses and not (
                'date' in entities and DbQueryParser._parse_event_date_entity(entities['date'][0])[
            2]):  # Если нет обычных where и нет special_sql_cond для даты
            # Можно по умолчанию искать события на сегодня, если ничего не указано
            where_clauses.append(sql.SQL('ev."Begin"::date = CURRENT_DATE'))
            print("Info: No specific criteria for event search, defaulting to today's events.")

        query_parts = [
            sql.SQL("SELECT"),
            sql.SQL("'EventList',"),
            sql.SQL(", ").join(select_fields),
            from_table
        ]
        query_parts.extend(joins)
        if where_clauses:
            query_parts.append(sql.SQL("WHERE ") + sql.SQL(" AND ").join(where_clauses))

        query_parts.append(sql.SQL('ORDER BY ev."Begin" ASC LIMIT 10'))

        final_query = sql.SQL(' ').join(query_parts)
        return final_query, params

    @staticmethod
    def _get_month_day_from_specifier(specifier_value: str) -> tuple[int | None, int | None, str | None]:
        specifier_lower = specifier_value.lower()
        if specifier_lower == "сегодня":
            return None, None, "TO_CHAR(emp.\"Birthday\", 'MM-DD') = TO_CHAR(CURRENT_DATE, 'MM-DD')"
        if specifier_lower == "завтра":
            return None, None, "TO_CHAR(emp.\"Birthday\", 'MM-DD') = TO_CHAR(CURRENT_DATE + INTERVAL '1 day', 'MM-DD')"
        if specifier_lower == "в этом месяце":
            return datetime.date.today().month, None, None
        for month_name, month_number in MONTH_NAME_TO_NUMBER.items():
            if month_name in specifier_lower:
                parts = specifier_lower.replace(month_name, "").strip().split()
                day = None
                for part in parts:
                    if part.isdigit():
                        day = int(part)
                        break
                return month_number, day, None
        if "зимой" in specifier_lower or "зима" in specifier_lower:
            return None, None, "EXTRACT(MONTH FROM emp.\"Birthday\") IN (12, 1, 2)"
        if "весной" in specifier_lower or "весна" in specifier_lower:
            return None, None, "EXTRACT(MONTH FROM emp.\"Birthday\") IN (3, 4, 5)"
        if "летом" in specifier_lower or "лето" in specifier_lower:
            return None, None, "EXTRACT(MONTH FROM emp.\"Birthday\") IN (6, 7, 8)"
        if "осенью" in specifier_lower or "осень" in specifier_lower:
            return None, None, "EXTRACT(MONTH FROM emp.\"Birthday\") IN (9, 10, 11)"
        return None, None, None

    @staticmethod
    def find_birthday(data: dict):
        entities = DbQueryParser._entities_to_dict(data.get('entities', []))
        select_fields = [
            sql.SQL('emp."Surname"'),
            sql.SQL('emp."Name"'),
            sql.SQL('emp."Father"'),
            sql.SQL('emp."Birthday"'),
            sql.SQL('dprt."Name" AS department_name'),
        ]
        from_table = sql.SQL('FROM "Employees" as emp')
        joins = [
            sql.SQL('LEFT JOIN "Department" as dprt ON dprt."Department_Id" = emp."DepartmentId"'),
        ]
        where_clauses = []
        params = []
        date_entity_values = entities.get('date', [])
        birthday_specifiers = entities.get('birthday_specifier', date_entity_values)
        if birthday_specifiers:
            specifier_val = birthday_specifiers[0]
            month, day, special_sql = DbQueryParser._get_month_day_from_specifier(specifier_val)
            if special_sql:
                where_clauses.append(sql.SQL(special_sql))
            elif month:
                where_clauses.append(sql.SQL('EXTRACT(MONTH FROM emp."Birthday") = %s'))
                params.append(month)
                if day:
                    where_clauses.append(sql.SQL('EXTRACT(DAY FROM emp."Birthday") = %s'))
                    params.append(day)
        if 'department' in entities:
            if not any('dprt ON' in str(j) for j in joins):
                joins.append(sql.SQL('LEFT JOIN "Department" as dprt ON dprt."Department_Id" = emp."DepartmentId"'))
            where_clauses.append(sql.SQL('dprt."Name" ILIKE %s'))
            params.append(f"%{entities['department'][0]}%")
        if 'name' in entities:
            name_val = entities['name'][0]
            if ' ' in name_val:
                parts = name_val.split(' ', 1)
                where_clauses.append(sql.SQL(
                    '((emp."Name" ILIKE %s AND emp."Surname" ILIKE %s) OR (emp."Name" ILIKE %s AND emp."Surname" ILIKE %s))'
                ))
                params.extend([f"%{parts[0]}%", f"%{parts[1]}%", f"%{parts[1]}%", f"%{parts[0]}%"])
            else:
                where_clauses.append(sql.SQL('(emp."Name" ILIKE %s OR emp."Surname" ILIKE %s)'))
                params.extend([f"%{name_val}%", f"%{name_val}%"])
        if 'age_older_than' in entities:
            try:
                age = int(entities['age_older_than'][0])
                where_clauses.append(sql.SQL('date_part(\'year\', age(emp."Birthday")) > %s'))
                params.append(age)
            except ValueError:
                print(f"Warning: could not parse age_older_than value: {entities['age_older_than'][0]}")
        if 'age_younger_than' in entities:
            try:
                age = int(entities['age_younger_than'][0])
                where_clauses.append(sql.SQL('date_part(\'year\', age(emp."Birthday")) < %s'))
                params.append(age)
            except ValueError:
                print(f"Warning: could not parse age_younger_than value: {entities['age_younger_than'][0]}")
        if not where_clauses:
            raise ValueError("Недостаточно критериев для поиска дней рождения.")

        query_parts = [
            sql.SQL("SELECT"),
            sql.SQL("'BirthdayList',"),
            sql.SQL(", ").join(select_fields),
            from_table
        ]
        query_parts.extend(joins)
        if where_clauses:
            query_parts.append(sql.SQL("WHERE ") + sql.SQL(" AND ").join(where_clauses))
        query_parts.append(sql.SQL(
            'ORDER BY EXTRACT(MONTH FROM emp."Birthday"), EXTRACT(DAY FROM emp."Birthday"), emp."Surname", emp."Name" LIMIT 10'))
        final_query = sql.SQL(' ').join(query_parts)
        return final_query, params

    @staticmethod
    def check_task(data: dict):
        entities = DbQueryParser._entities_to_dict(data.get('entities', []))
        select_fields = [
            sql.SQL('tsk."Name" AS task_name'),
            sql.SQL('tsk."Descri..." AS task_description'),
            sql.SQL('tsk."Begin" AS task_deadline'),
            sql.SQL('emp_assignee."Name" AS assignee_name'),
            sql.SQL('emp_assignee."Surname" AS assignee_surname'),
            sql.SQL('prj."Name" AS project_name')
        ]
        from_table = sql.SQL('FROM "Task" as tsk')
        joins = [
            sql.SQL('LEFT JOIN "Employees" as emp_assignee ON emp_assignee."Employee_Id" = tsk."EmployeeId"'),
            sql.SQL('LEFT JOIN "Project" as prj ON prj."Project_Id" = emp_assignee."ProjectId"')
        ]
        where_clauses = []
        params = []
        if 'name' in entities:
            name_val = entities['name'][0]
            if name_val.lower() in ["мои", "меня", "я", "мне"]:
                print("Warning: 'мои' задачи требуют ID текущего пользователя, который здесь не доступен.")
            else:
                if ' ' in name_val:
                    parts = name_val.split(' ', 1)
                    where_clauses.append(sql.SQL(
                        '((emp_assignee."Name" ILIKE %s AND emp_assignee."Surname" ILIKE %s) OR (emp_assignee."Name" ILIKE %s AND emp_assignee."Surname" ILIKE %s))'
                    ))
                    params.extend([f"%{parts[0]}%", f"%{parts[1]}%", f"%{parts[1]}%", f"%{parts[0]}%"])
                else:
                    where_clauses.append(sql.SQL('(emp_assignee."Name" ILIKE %s OR emp_assignee."Surname" ILIKE %s)'))
                    params.extend([f"%{name_val}%", f"%{name_val}%"])
        if 'project' in entities:
            if not any('prj ON prj."Project_Id" = emp_assignee."ProjectId"' in str(j) for j in joins):
                joins.append(sql.SQL(
                    'LEFT JOIN "Project" as prj_task_filter ON prj_task_filter."Project_Id" = emp_assignee."ProjectId"'))
                where_clauses.append(sql.SQL('prj_task_filter."Name" ILIKE %s'))
            else:
                where_clauses.append(sql.SQL('prj."Name" ILIKE %s'))
            params.append(f"%{entities['project'][0]}%")
        if 'date' in entities:
            date_str = entities['date'][0]
            if date_str.lower() == "сегодня":
                where_clauses.append(sql.SQL('tsk."Begin"::date = CURRENT_DATE'))
            elif date_str.lower() == "завтра":
                where_clauses.append(sql.SQL('tsk."Begin"::date = CURRENT_DATE + INTERVAL \'1 day\''))
            elif "на эт" in date_str.lower() and "недел" in date_str.lower():
                where_clauses.append(sql.SQL(
                    'tsk."Begin"::date >= date_trunc(\'week\', CURRENT_DATE) AND tsk."Begin"::date < date_trunc(\'week\', CURRENT_DATE) + INTERVAL \'1 week\''))
            else:
                try:
                    parsed_date = datetime.datetime.strptime(date_str, "%d.%m.%Y").date()
                    where_clauses.append(sql.SQL('tsk."Begin"::date = %s'))
                    params.append(parsed_date)
                except ValueError:
                    print(f"Warning: Could not parse date string '{date_str}' for task deadline.")
        if 'task_status' in entities: print(
            f"Warning: Task status filtering not supported by DB schema. Entity: {entities['task_status'][0]}")
        if 'task_priority' in entities: print(
            f"Warning: Task priority filtering not supported by DB schema. Entity: {entities['task_priority'][0]}")
        if 'task_tag' in entities: print(
            f"Warning: Task tag filtering not supported by DB schema. Entity: {entities['task_tag'][0]}")
        if 'task_name' in entities:
            where_clauses.append(sql.SQL('tsk."Name" ILIKE %s'))
            params.append(f"%{entities['task_name'][0]}%")
        if not where_clauses:
            raise ValueError("Недостаточно критериев для поиска задач.")

        query_parts = [
            sql.SQL("SELECT"),
            sql.SQL("'TaskList',"),
            sql.SQL(", ").join(select_fields),
            from_table
        ]
        query_parts.extend(joins)
        if where_clauses:
            query_parts.append(sql.SQL("WHERE ") + sql.SQL(" AND ").join(where_clauses))
        query_parts.append(sql.SQL('ORDER BY tsk."Begin" ASC NULLS LAST LIMIT 10'))
        final_query = sql.SQL(' ').join(query_parts)
        return final_query, params

    @staticmethod
    def _entities_to_dict(entities: list) -> dict:
        result = {}
        if not entities:
            return result
        for entity in entities:
            entity_type = entity.get("entity")
            entity_value = entity.get("value")
            if entity_type and entity_value is not None:
                if entity_type not in result:
                    result[entity_type] = [entity_value]
                else:
                    result[entity_type].append(entity_value)
        return result

================================================================================

# Файл: db_response_parser.py
# Содержимое:
# Файл: db_response_parser.py
import textwrap
import datetime


class DbResponseParser:
    @staticmethod
    def parse_into_message(data_list: list) -> str:
        if not data_list or not data_list[0]:
            return "По вашему запросу ничего не найдено."
        first_record = data_list[0]
        result_type = first_record[0]

        match result_type:
            case "PersonInfo":
                return DbResponseParser.parse_person(first_record)
            case "BirthdayList":
                return DbResponseParser.parse_birthday_results(data_list)
            case "TaskList":
                return DbResponseParser.parse_task_results(data_list)
            case "EventList":  # ИЗМЕНЕНО
                return DbResponseParser.parse_event_results(data_list)
            case _:
                return f"Неизвестный тип результата для отображения: {result_type}"

    @staticmethod
    def parse_person(data_row: tuple) -> str:
        contacts = data_row[10] if len(data_row) > 10 and data_row[10] else {}
        phone = contacts.get("phone")
        email = contacts.get("email")
        birthday_str = data_row[4].strftime("%d.%m.%Y") if data_row[4] else "-"
        firstday_str = data_row[5].strftime("%d.%m.%Y") if data_row[5] else "-"
        return textwrap.dedent(f'''
                Нашёл первое совпадение:

                <b>{data_row[1] or ""} {data_row[2] or ""} {data_row[3] or ""}</b>
                <b>День рождения:</b> {birthday_str}
                <b>Вступил в должность:</b> {firstday_str}
                <b>Пишет на:</b> {data_row[6] or "-"}
                <b>Грейд:</b> {data_row[7] or "-"}
                <b>Сейчас работает над проектом:</b> {data_row[8] or "-"}
                <b>Состоит в отделе:</b> {data_row[9] or "-"}
                {f"<b>Почта:</b> {email}" if email else "<b>Почта:</b> -"}
                {f"<b>Номер телефона:</b> {phone}" if phone else "<b>Номер телефона:</b> -"}
            ''').strip()

    @staticmethod
    def parse_birthday_results(data_list: list) -> str:
        if not data_list:
            return "Дни рождения по вашим критериям не найдены."
        messages = ["<b>Найдены следующие дни рождения:</b>"]
        for row in data_list:
            surname = row[1] or ""
            name = row[2] or ""
            father = row[3] or ""
            birthday_date = row[4]
            department_name = row[5] or "Не указан"
            birthday_str = birthday_date.strftime("%d.%m") if isinstance(birthday_date, (
            datetime.date, datetime.datetime)) else "Дата не указана"
            person_info = f"{surname} {name} {father}".strip()
            messages.append(f"- {person_info} ({birthday_str}), Отдел: {department_name}")
        if len(messages) == 1:
            return "Дни рождения по вашим критериям не найдены."
        return "\n".join(messages)

    @staticmethod
    def parse_task_results(data_list: list) -> str:
        if not data_list:
            return "Задачи по вашим критериям не найдены."
        messages = ["<b>Найдены следующие задачи:</b>"]
        for row in data_list:
            task_name_val = row[1] or "Без названия"
            description_val = row[2] or "Нет описания"
            deadline_val = row[3].strftime("%d.%m.%Y %H:%M") if isinstance(row[3], (
            datetime.date, datetime.datetime)) else "Нет даты"
            status_val = "-"
            priority_val = "-"
            assignee_name_val = row[4] or ""
            assignee_surname_val = row[5] or ""
            project_name_val = row[6] or "Без проекта"
            assignee_full_name = f"{assignee_surname_val} {assignee_name_val}".strip()
            task_info = f"<b>{task_name_val}</b> (Проект: {project_name_val})"
            task_info += f"\n  <i>Описание:</i> {description_val}"
            task_info += f"\n  Исполнитель: {assignee_full_name if assignee_full_name else '-'}"
            task_info += f"\n  Дата/Дедлайн: {deadline_val}, Статус: {status_val}, Приоритет: {priority_val}"
            messages.append(task_info)
        if len(messages) == 1:
            return "Задачи по вашим критериям не найдены."
        return "\n\n".join(messages)

    @staticmethod
    def parse_event_results(data_list: list) -> str:
        if not data_list:
            return "Мероприятия по вашим критериям не найдены."

        messages = ["<b>Найдены следующие мероприятия:</b>"]
        for row in data_list:
            # Индексы соответствуют select_fields в search_event:
            # row[0] - 'EventList' (маркер)
            # row[1] - event_name
            # row[2] - event_begin (TIMESTAMPTZ)
            # row[3] - event_duration (INTERVAL)
            # row[4] - category_name
            # row[5] - event_description
            # row[6] - organizer_name
            # row[7] - organizer_surname

            event_name = row[1] or "Без названия"
            event_begin_dt = row[2]  # datetime.datetime object
            event_duration_td = row[3]  # datetime.timedelta object
            category_name = row[4] or "Не указана"
            description = row[5] or "Нет описания"
            organizer_name = row[6] or ""
            organizer_surname = row[7] or ""

            organizer_full_name = f"{organizer_surname} {organizer_name}".strip()
            if not organizer_full_name:
                organizer_full_name = "Не указан"

            begin_str = event_begin_dt.strftime("%d.%m.%Y в %H:%M") if event_begin_dt else "Время не указано"

            duration_str = ""
            if event_duration_td:
                hours, remainder = divmod(event_duration_td.total_seconds(), 3600)
                minutes, _ = divmod(remainder, 60)
                if hours > 0 and minutes > 0:
                    duration_str = f"{int(hours)} ч {int(minutes)} мин"
                elif hours > 0:
                    duration_str = f"{int(hours)} ч"
                elif minutes > 0:
                    duration_str = f"{int(minutes)} мин"
                else:  # если очень короткое, покажем в секундах или пропустим
                    if event_duration_td.total_seconds() > 0:
                        duration_str = f"{int(event_duration_td.total_seconds())} сек"

            event_info = f"<b>{event_name}</b> (Категория: {category_name})"
            event_info += f"\n  <i>Начало:</i> {begin_str}"
            if duration_str:
                event_info += f", <i>Длительность:</i> {duration_str}"
            event_info += f"\n  <i>Организатор:</i> {organizer_full_name}"
            if description and description != "Нет описания":
                event_info += f"\n  <i>Описание:</i> {textwrap.shorten(description, width=100, placeholder='...')}"  # Сокращаем длинное описание

            messages.append(event_info)

        if len(messages) == 1:  # Только заголовок
            return "Мероприятия по вашим критериям не найдены."
        return "\n\n".join(messages)

================================================================================

# Файл: main.py
# Содержимое:
import json
import logging
import textwrap

import requests
from telegram import Update, ReplyKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
)
from ai_request_processor import AiRequestProcessor
from database_query_parser import DbQueryParser
from db_response_parser import DbResponseParser
from database import Database

DB_CONFIG = {
    "dbname": "interesich",
    "user": "cock_userr",
    "password": "ifconfigroute-3n",
    "host": "51.250.112.217",
    "port": "5432"
}

db = Database(**DB_CONFIG)

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Убедитесь, что Rasa NLU сервер запущен на этом адресе и порту
ai_request_processor = AiRequestProcessor(base_url="http://localhost:5005/model/parse")

BOT_TOKEN = '7757580544:AAHMXO0sgFFvNJMIDksbxqc9zYHrNNGo-rA'  # Ваш токен

reply_keyboard = [['/help']]
markup = ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Добро пожаловать! Я помогу вам найти информацию о сотрудниках, мероприятиях, задачах и днях рождения. Нажмите /help, чтобы узнать больше.",
        reply_markup=markup
    )


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_text = """
Вы можете спросить меня:
- "Найди Иванова Петра"
- "Какие мероприятия завтра?"
- "У кого день рождения в июне?"
- "Мои задачи на сегодня"
- "Свободен ли я завтра в 10?"

Просто напишите ваш вопрос в свободной форме!
    """
    await update.message.reply_text(
        textwrap.dedent(help_text),
        reply_markup=markup
    )


async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    logger.info(f"Получен запрос от пользователя: {text}")
    try:
        ai_response = ai_request_processor.process_query(text)
        logger.info(f"Ответ от NLU: {json.dumps(ai_response, ensure_ascii=False, indent=2)}")

        query_data = DbQueryParser.parse(ai_response)

        sql_query = None
        query_params = None

        if isinstance(query_data, tuple):
            sql_query, query_params = query_data
        else:  # Для обратной совместимости со старыми методами, возвращающими только строку
            sql_query = query_data
            query_params = None

        logger.info(f"Сформирован SQL: {sql_query} с параметрами: {query_params}")

        db_result = db.execute_query(query=sql_query, params=query_params, fetch=True)

        if not db_result:  # Проверяем, если результат пустой или None
            message = "По вашему запросу ничего не найдено."
            logger.info("БД не вернула результатов.")
        else:
            logger.info(f"Результат из БД: {db_result}")
            message = DbResponseParser.parse_into_message(db_result)

    except requests.exceptions.RequestException as e:
        logger.error(f"Ошибка при обращении к Rasa NLU API: {e}")
        message = "Извините, не удалось связаться с сервисом распознавания. Попробуйте позже."
    except ValueError as e:  # Для ошибок парсинга или отсутствия данных
        logger.warning(f"Ошибка обработки запроса: {e}")
        message = f"Не удалось обработать ваш запрос: {e}"
    except Exception as e:
        logger.exception(f"Произошла непредвиденная ошибка: {e}")  # Логируем полный стектрейс
        message = "Произошла внутренняя ошибка. Пожалуйста, попробуйте позже."
    await update.message.reply_text(str(sql_query), reply_markup=markup, parse_mode=ParseMode.HTML)
    await update.message.reply_text(message, reply_markup=markup, parse_mode=ParseMode.HTML)


def main():
    app = ApplicationBuilder().token(BOT_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(
        MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text)
    )

    logger.info("Бот запущен...")
    app.run_polling()


if __name__ == '__main__':
    main()

================================================================================

# Файл: README.md
# Содержимое:
# very-interesting-case



================================================================================

# Файл: requirements.txt
# Содержимое:
python-telegram-bot==22.1
psycopg2==2.9.10

================================================================================

# Файл: tools.py
# Содержимое:
import os


def gather_files_to_txt(root_folder, output_filename="combined_code.txt", ignore_dirs=None, ignore_extensions=None,
                        ignore_files=None):
    """
    Собирает все текстовые файлы из указанной папки и ее подпапок в один TXT-файл.
    Перед содержимым каждого файла добавляется комментарий с его относительным путем.

    :param root_folder: Корневая папка для поиска файлов.
    :param output_filename: Имя итогового TXT-файла.
    :param ignore_dirs: Список имен папок, которые нужно игнорировать (например, ['.git', '__pycache__']).
    :param ignore_extensions: Список расширений файлов, которые нужно игнорировать (например, ['.pyc', '.log']).
    :param ignore_files: Список имен файлов, которые нужно игнорировать (например, ['output.txt']).
    """
    if ignore_dirs is None:
        ignore_dirs = ['.git', '__pycache__', 'node_modules', '.venv', 'venv', 'build', 'dist', '.rasa', 'rasa']
    if ignore_extensions is None:
        # По умолчанию пытаемся взять большинство текстовых/кодовых файлов, но можно настроить
        ignore_extensions = [
            '.pyc', '.pyo', '.pyd', '.so', '.dll', '.exe', '.o', '.a', '.lib',  # скомпилированные
            '.log', '.tmp', '.bak', '.swp', '.swo',  # временные/логи
            '.DS_Store', '.Spotlight-V100', '.Trashes', 'ehthumbs.db', 'Thumbs.db',  # системные
            '.gz', '.zip', '.tar', '.rar', '.7z',  # архивы
            '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.svg', '.ico',  # изображения
            '.mp3', '.wav', '.ogg', '.flac', '.aac',  # аудио
            '.mp4', '.mov', '.avi', '.mkv', '.webm',  # видео
            '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.odt', '.ods', '.odp',  # документы
            '.tar.gz', '.tar.bz2', '.tar.xz',
            '.gitignore'# архивы
        ]
    if ignore_files is None:
        ignore_files = []

    # Добавляем сам выходной файл в список игнорируемых, чтобы он сам себя не добавил
    # если запускать скрипт из той же папки, где он будет создан
    base_output_filename = os.path.basename(output_filename)
    if base_output_filename not in ignore_files:
        ignore_files.append(base_output_filename)

    if not os.path.isdir(root_folder):
        print(f"Ошибка: Папка '{root_folder}' не найдена.")
        return

    collected_files_count = 0
    output_abs_path = os.path.abspath(os.path.join(root_folder, output_filename))
    # Если output_filename содержит путь, используем его, иначе создаем в root_folder
    if os.path.dirname(output_filename):
        output_abs_path = os.path.abspath(output_filename)
    else:
        output_abs_path = os.path.abspath(os.path.join(root_folder, output_filename))

    with open(output_abs_path, 'w', encoding='utf-8') as outfile:
        for dirpath, dirnames, filenames in os.walk(root_folder):
            # Исключаем папки из дальнейшего обхода
            dirnames[:] = [d for d in dirnames if d not in ignore_dirs]

            for filename in filenames:
                if filename in ignore_files:
                    # print(f"Пропуск файла (в списке игнорируемых): {filename}")
                    continue

                file_ext = os.path.splitext(filename)[1].lower()
                if file_ext in ignore_extensions:
                    # print(f"Пропуск файла (расширение в списке игнорируемых): {filename}")
                    continue


                full_path = os.path.join(dirpath, filename)

                # Проверяем, не является ли это сам выходной файл (на случай если он уже существует)
                if os.path.abspath(full_path) == output_abs_path:
                    continue

                relative_path = os.path.relpath(full_path, root_folder)
                # Заменяем разделители пути Windows на Unix-подобные для единообразия
                comment_path = relative_path.replace(os.sep, '/')

                try:
                    with open(full_path, 'r', encoding='utf-8', errors='ignore') as infile:
                        content = infile.read()

                    outfile.write(f"# Файл: {comment_path}\n")
                    outfile.write("# Содержимое:\n")
                    outfile.write(content)
                    outfile.write("\n\n" + "=" * 80 + "\n\n")  # Разделитель между файлами
                    collected_files_count += 1
                    print(f"Добавлен: {relative_path}")

                except Exception as e:
                    # Если файл не текстовый или проблема с кодировкой, которую errors='ignore' не решила
                    print(
                        f"Не удалось прочитать файл (возможно, бинарный или проблема с кодировкой): {relative_path} - {e}")
                    outfile.write(f"# Файл (НЕ УДАЛОСЬ ПРОЧИТАТЬ): {comment_path}\n")
                    outfile.write(f"# Ошибка: {e}\n")
                    outfile.write("\n\n" + "=" * 80 + "\n\n")

    if collected_files_count > 0:
        print(f"\nГотово! {collected_files_count} файлов собрано в '{output_abs_path}'.")
    else:
        print(
            f"\nВ папке '{root_folder}' не найдено подходящих файлов (с учетом фильтров). Файл '{output_abs_path}' создан, но пуст или содержит только ошибки чтения.")


if __name__ == "__main__":
    # --- Настройки ---
    target_folder = r"D:\wonderfulprojects\very-interesting-case"  # Текущая папка. Можно указать абсолютный или относительный путь, например "my_project_folder"
    # target_folder = "C:/Users/YourUser/Projects/MyAwesomeProject"

    output_file_name = "project_code_combined.txt"  # Имя итогового файла

    # Список папок для игнорирования (дополните при необходимости)
    custom_ignore_dirs = ['.git', '__pycache__', 'node_modules', '.venv', 'venv', 'build', 'dist', 'target', '.idea',
                          '.vscode', '.rasa']

    # Список расширений для игнорирования (дополните при необходимости)
    # Расширения, которые точно не являются текстовым кодом или конфигурацией
    custom_ignore_extensions = [
        '.gz', '.gitignore', '.gitattributes'
        # '.pyc', '.pyo', '.pyd', '.so', '.dll', '.exe', '.o', '.a', '.lib',  # скомпилированные
        # '.log', '.tmp', '.bak', '.swp', '.swo',  # временные/логи
        # '.DS_Store', '.Spotlight-V100', '.Trashes', 'ehthumbs.db', 'Thumbs.db',  # системные
        # '.gz', '.zip', '.tar', '.rar', '.7z',  # архивы
        # '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.svg', '.ico',  # изображения
        # '.mp3', '.wav', '.ogg', '.flac', '.aac',  # аудио
        # '.mp4', '.mov', '.avi', '.mkv', '.webm',  # видео
        # '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.odt', '.ods', '.odp',  # документы
        # '.jar', '.war',  # Java архивы
        # '.woff', '.woff2', '.ttf', '.eot',  # шрифты
    ]
    # Если хотите наоборот, указать только те расширения, которые включать,
    # то этот скрипт нужно будет немного доработать. Текущая логика - исключение.

    # Список конкретных файлов для игнорирования
    custom_ignore_files = [output_file_name] + ['.gitattributes', '.gitignore'] # Автоматически добавится, но можно добавить и свои
    # custom_ignore_files.append("README.md") # Например, если не хотите включать README

    # --- Запуск ---
    print(f"Сбор файлов из папки: {os.path.abspath(target_folder)}")
    print(
        f"Результат будет сохранен в: {os.path.abspath(os.path.join(target_folder, output_file_name)) if not os.path.dirname(output_file_name) else os.path.abspath(output_file_name)}")

    gather_files_to_txt(
        target_folder,
        output_file_name,
        ignore_dirs=custom_ignore_dirs,
        ignore_extensions=custom_ignore_extensions,
        ignore_files=custom_ignore_files
    )

================================================================================

