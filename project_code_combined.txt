# Файл: ai_request_processor.py
# Содержимое:
import requests
import json


class AiRequestProcessor:
    def __init__(self, base_url: str):
        self.base_url = base_url

    def process_query(self, query: str) -> dict:
        payload = {"text": query}
        try:
            response = requests.post(self.base_url, json=payload)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            print(f"Ошибка при обращении к Rasa NLU API: {e}")
            raise



================================================================================

# Файл: database.py
# Содержимое:
import psycopg2
from psycopg2 import sql
from psycopg2.extras import DictCursor


class Database:
    def __init__(self, dbname, user, password, host="localhost", port="5432"):
        """Инициализация подключения к базе данных."""
        self.conn = None
        self.cursor = None
        try:
            self.conn = psycopg2.connect(
                dbname=dbname,
                user=user,
                password=password,
                host=host,
                port=port
            )
            # Используем DictCursor для получения результатов в виде словаря
            self.cursor = self.conn.cursor(cursor_factory=DictCursor)
            print("Подключение к базе данных успешно установлено.")
        except Exception as e:
            print(f"Ошибка подключения к базе данных: {e}")

    def execute_query(self, query, params=None, fetch=False):
        """Выполняет SQL-запрос и возвращает результат (если fetch=True)."""
        try:
            self.cursor.execute(query, params)
            if fetch:
                return self.cursor.fetchall()
            self.conn.commit()
        except Exception as e:
            self.conn.rollback()
            print(f"Ошибка выполнения запроса: {e}")
            return None

    def close(self):
        """Закрывает соединение с базой данных."""
        if self.cursor:
            self.cursor.close()
        if self.conn:
            self.conn.close()
        print("Соединение с базой данных закрыто.")

    def __del__(self):
        """Деструктор - автоматически закрывает соединение при удалении объекта."""
        self.close()

================================================================================

# Файл: database_query_parser.py
# Содержимое:
import datetime
from psycopg2 import sql

# Словарь для преобразования названий месяцев и их форм в номера
MONTH_NAME_TO_NUMBER = {
    "январь": 1, "января": 1, "январе": 1,
    "февраль": 2, "февраля": 2, "феврале": 2,
    "март": 3, "марта": 3, "марте": 3,
    "апрель": 4, "апреля": 4, "апреле": 4,
    "май": 5, "мая": 5, "мае": 5,
    "июнь": 6, "июня": 6, "июне": 6,
    "июль": 7, "июля": 7, "июле": 7,
    "август": 8, "августа": 8, "августе": 8,
    "сентябрь": 9, "сентября": 9, "сентябре": 9,
    "октябрь": 10, "октября": 10, "октябре": 10,
    "ноябрь": 11, "ноября": 11, "ноябре": 11,
    "декабрь": 12, "декабря": 12, "декабре": 12,
}


class DbQueryParser:
    @staticmethod
    def parse(data: dict):  # -> Union[str, Tuple[sql.Composed, list]]: # Python 3.9 needs Tuple from typing
        intent_name = data.get("intent", {}).get("name")
        if not intent_name:
            raise ValueError("Intent name is missing in NLU data")

        match intent_name:
            case "search_person":
                return DbQueryParser.search_person(data)
            case "search_event":
                return DbQueryParser.search_event(data)  # This still needs get_date and parameterization
            case "find_birthday":
                return DbQueryParser.find_birthday(data)
            case "check_task":
                return DbQueryParser.check_task(data)
            # Добавьте сюда другие интенты, если они будут

        raise ValueError(f"Неизвестный интент: {intent_name}")

    @staticmethod
    def search_person(data: dict) -> str:
        # ЭТОТ МЕТОД ВСЕ ЕЩЕ ИСПОЛЬЗУЕТ ФОРМАТИРОВАНИЕ СТРОК - РЕКОМЕНДУЕТСЯ РЕФАКТОРИНГ
        for entity in data.get('entities', []):
            if entity.get('entity') == 'name':
                # SQL-инъекция возможна здесь!
                return f'''
                    SELECT 
                        'PersonInfo',
                        emp."Surname", 
                        emp."Name", 
                        emp."Father", 
                        emp."Birthday", 
                        emp."FirstDay", 
                        lng."Name" as "LanguageName", 
                        rnk."Status" as "RankStatus",
                        prj."Name" as "ProjectName",
                        dprt."Name" as "DepartmentName",
                        emp."Contacts"
                    FROM "Employees" as emp
                    LEFT JOIN "Languages" as lng ON lng."Language_Id"=emp."LanguageId"
                    LEFT JOIN "Rank" as rnk ON rnk."Rank_Id" = emp."RankId"
                    LEFT JOIN "Project" as prj ON prj."Project_Id"=emp."ProjectId"
                    LEFT JOIN "Department" as dprt ON dprt."Department_Id"=emp."DepartmentId"
                    WHERE emp."Name" ILIKE '%{entity['value']}%' OR emp."Surname" ILIKE '%{entity['value']}%'
                    LIMIT 1;
                    '''
        # Возвращаем пустую строку или специфический запрос, если имя не найдено,
        # чтобы избежать ошибки в main.py, если интент search_person, но нет имени.
        # Либо можно выбросить исключение, которое будет обработано в main.py.
        # Для консистентности с find_birthday, лучше выбрасывать исключение, если нет ключевых данных.
        raise ValueError("Сущность 'name' не найдена для search_person")

    @staticmethod
    def search_event(data: dict) -> str:
        # ЭТОТ МЕТОД ТРЕБУЕТ get_date() И ПАРАМЕТРИЗАЦИИ
        entities: list = data.get('entities', [])
        keywords = DbQueryParser._entities_to_dict(entities)

        where_clauses = []
        if 'event_name' in keywords:
            # SQL-инъекция возможна здесь!
            where_clauses.append(f"""ev."Name" ILIKE '%{keywords['event_name'][0]}%'""")
        if 'date' in keywords:
            # Здесь должна быть логика get_date и корректное форматирование даты
            # Пока что это заглушка, предполагающая, что get_date вернет строку YYYY-MM-DD
            # date_str = DbQueryParser.get_date_placeholder(keywords['date'][0])
            # where_clauses.append(f"""ev."Begin" >= '{date_str}'""") # Пример
            where_clauses.append("1=1")  # Заглушка, чтобы запрос был валидным

        # if 'location' in keywords: ...
        # if 'event_category' in keywords: ...

        query_str = """
            SELECT 'EventInfo', ev."Name", ev."Begin", ev."Duration", cat."Name" as "CategoryName"
            FROM "Events" as ev
            LEFT JOIN "Categories" as cat ON cat."Category_Id" = ev."CategoryId"
        """
        if where_clauses:
            query_str += " WHERE " + " AND ".join(where_clauses)
        query_str += " LIMIT 5;"

        print(f"[DEBUG] search_event SQL (needs proper date handling & parameterization): {query_str}")
        return query_str

    @staticmethod
    def _get_month_day_from_specifier(specifier_value: str) -> tuple[int | None, int | None, str | None]:
        """ Пытается извлечь месяц и день из текстового спецификатора.
            Возвращает (месяц, день,特殊SQLусловие)
        """
        specifier_lower = specifier_value.lower()

        # "сегодня", "завтра"
        if specifier_lower == "сегодня":
            return None, None, "TO_CHAR(emp.\"Birthday\", 'MM-DD') = TO_CHAR(CURRENT_DATE, 'MM-DD')"
        if specifier_lower == "завтра":
            return None, None, "TO_CHAR(emp.\"Birthday\", 'MM-DD') = TO_CHAR(CURRENT_DATE + INTERVAL '1 day', 'MM-DD')"

        # "на этой неделе" - сложно для годовой повторяемости, лучше на уровне приложения или более сложный SQL
        # "в этом месяце"
        if specifier_lower == "в этом месяце":
            return datetime.date.today().month, None, None

        # "в <месяц>"
        for month_name, month_number in MONTH_NAME_TO_NUMBER.items():
            if month_name in specifier_lower:
                # Попробуем найти число (день) перед или после месяца
                parts = specifier_lower.replace(month_name, "").strip().split()
                day = None
                for part in parts:
                    if part.isdigit():
                        day = int(part)
                        break
                return month_number, day, None

        # Простые сезоны (примерная реализация)
        if "зимой" in specifier_lower or "зима" in specifier_lower:
            return None, None, "EXTRACT(MONTH FROM emp.\"Birthday\") IN (12, 1, 2)"
        if "весной" in specifier_lower or "весна" in specifier_lower:
            return None, None, "EXTRACT(MONTH FROM emp.\"Birthday\") IN (3, 4, 5)"
        if "летом" in specifier_lower or "лето" in specifier_lower:
            return None, None, "EXTRACT(MONTH FROM emp.\"Birthday\") IN (6, 7, 8)"
        if "осенью" in specifier_lower or "осень" in specifier_lower:
            return None, None, "EXTRACT(MONTH FROM emp.\"Birthday\") IN (9, 10, 11)"

        return None, None, None  # Не удалось распознать

    @staticmethod
    def find_birthday(data: dict):  # -> Tuple[sql.Composed, list]
        entities = DbQueryParser._entities_to_dict(data.get('entities', []))

        select_fields = [
            sql.SQL('emp."Surname"'),
            sql.SQL('emp."Name"'),
            sql.SQL('emp."Father"'),
            sql.SQL('emp."Birthday"'),
            sql.SQL('dprt."Name"').AS('department_name'),
            # sql.SQL('prj."Name"').AS('project_name') # Если нужно будет фильтровать/отображать проект
        ]
        from_table = sql.SQL('FROM "Employees" as emp')
        joins = [
            sql.SQL('LEFT JOIN "Department" as dprt ON dprt."Department_Id" = emp."DepartmentId"'),
            # sql.SQL('LEFT JOIN "Project" as prj ON prj."Project_Id" = emp."ProjectId"')
        ]
        where_clauses = []
        params = []

        # Обработка birthday_specifier и date
        # Приоритет отдается birthday_specifier, если есть оба
        date_entity_values = entities.get('date', [])
        birthday_specifiers = entities.get('birthday_specifier',
                                           date_entity_values)  # Используем date, если нет specifier

        processed_date_condition = False
        if birthday_specifiers:
            # Берем первый попавшийся спецификатор/дату для простоты
            # В более сложной системе можно было бы обрабатывать диапазоны и т.д.
            specifier_val = birthday_specifiers[0]
            month, day, special_sql = DbQueryParser._get_month_day_from_specifier(specifier_val)
            if special_sql:
                where_clauses.append(sql.SQL(special_sql))
                processed_date_condition = True
            elif month:
                where_clauses.append(sql.SQL('EXTRACT(MONTH FROM emp."Birthday") = %s'))
                params.append(month)
                if day:
                    where_clauses.append(sql.SQL('EXTRACT(DAY FROM emp."Birthday") = %s'))
                    params.append(day)
                processed_date_condition = True

        # Если ни один спецификатор/дата не обработан, и есть общие запросы без даты
        # (например, "дни рождения в отделе маркетинга" - это на весь год), то условие по дате не добавляем.
        # Если интент find_birthday, но нет даты, это может быть запрос на ДР конкретного человека.
        # if not processed_date_condition and not entities.get('name'):
        #     raise ValueError("Не указан период или дата для поиска дней рождения.")

        if 'department' in entities:
            # Проверяем, есть ли уже JOIN для Department, чтобы не дублировать
            if not any('dprt ON' in str(j) for j in joins):  # Простая проверка
                joins.append(sql.SQL('LEFT JOIN "Department" as dprt ON dprt."Department_Id" = emp."DepartmentId"'))
            where_clauses.append(sql.SQL('dprt."Name" ILIKE %s'))
            params.append(f"%{entities['department'][0]}%")

        # if 'project' in entities:
        #     if not any('prj ON' in str(j) for j in joins):
        #         joins.append(sql.SQL('LEFT JOIN "Project" as prj ON prj."Project_Id" = emp."ProjectId"'))
        #     where_clauses.append(sql.SQL('prj."Name" ILIKE %s'))
        #     params.append(f"%{entities['project'][0]}%")

        if 'name' in entities:
            name_val = entities['name'][0]
            # Если имя содержит пробел, скорее всего это Имя + Фамилия или наоборот
            if ' ' in name_val:
                parts = name_val.split(' ', 1)
                where_clauses.append(sql.SQL(
                    '((emp."Name" ILIKE %s AND emp."Surname" ILIKE %s) OR (emp."Name" ILIKE %s AND emp."Surname" ILIKE %s))'
                ))
                params.extend([f"%{parts[0]}%", f"%{parts[1]}%", f"%{parts[1]}%", f"%{parts[0]}%"])
            else:  # Иначе ищем по имени или фамилии
                where_clauses.append(sql.SQL('(emp."Name" ILIKE %s OR emp."Surname" ILIKE %s)'))
                params.extend([f"%{name_val}%", f"%{name_val}%"])

        if 'age_older_than' in entities:
            try:
                age = int(entities['age_older_than'][0])
                where_clauses.append(sql.SQL('date_part(\'year\', age(emp."Birthday")) > %s'))
                params.append(age)
            except ValueError:
                print(f"Warning: could not parse age_older_than value: {entities['age_older_than'][0]}")

        if 'age_younger_than' in entities:
            try:
                age = int(entities['age_younger_than'][0])
                where_clauses.append(sql.SQL('date_part(\'year\', age(emp."Birthday")) < %s'))
                params.append(age)
            except ValueError:
                print(f"Warning: could not parse age_younger_than value: {entities['age_younger_than'][0]}")

        if not where_clauses:  # Если нет условий, то запрос может вернуть слишком много.
            raise ValueError("Недостаточно критериев для поиска дней рождения.")

        query_parts = [sql.SQL("SELECT 'BirthdayList',")]
        query_parts.extend(select_fields)
        query_parts.append(from_table)
        query_parts.extend(joins)

        query_parts.append(sql.SQL("WHERE ") + sql.SQL(" AND ").join(where_clauses))
        query_parts.append(sql.SQL(
            'ORDER BY EXTRACT(MONTH FROM emp."Birthday"), EXTRACT(DAY FROM emp."Birthday"), emp."Surname", emp."Name" LIMIT 10'))

        final_query = sql.SQL(' ').join(query_parts)
        return final_query, params

    @staticmethod
    def check_task(data: dict):  # -> Tuple[sql.Composed, list]
        entities = DbQueryParser._entities_to_dict(data.get('entities', []))

        select_fields = [
            sql.SQL('tsk."Name"').AS('task_name'),
            sql.SQL('tsk."Description"'),
            sql.SQL('tsk."Deadline"'),
            sql.SQL('tsk."Status"'),
            sql.SQL('tsk."Priority"'),
            sql.SQL('emp_assignee."Name"').AS('assignee_name'),
            sql.SQL('emp_assignee."Surname"').AS('assignee_surname'),
            sql.SQL('prj."Name"').AS('project_name')
        ]
        from_table = sql.SQL('FROM "Tasks" as tsk')  # Предполагаем, что таблица Tasks
        joins = [
            sql.SQL('LEFT JOIN "Employees" as emp_assignee ON emp_assignee."Employee_Id" = tsk."AssigneeId"'),
            # Предполагаем AssigneeId
            sql.SQL('LEFT JOIN "Project" as prj ON prj."Project_Id" = tsk."ProjectId"')  # Предполагаем ProjectId
        ]
        where_clauses = []
        params = []

        # Если есть "мои", ищем задачи текущего пользователя (потребуется ID пользователя, здесь не доступен)
        # Пока что, если есть name, ищем по нему. Если "мои", это нужно обработать на более высоком уровне
        # или передать user_id в этот парсер.
        if 'name' in entities:
            name_val = entities['name'][0]
            if name_val.lower() in ["мои", "меня", "я", "мне"]:  # Обработка "моих" задач
                # Здесь нужна логика для получения ID текущего пользователя.
                # Для примера, поставим заглушку или пропустим, если ID не доступен.
                # where_clauses.append(sql.SQL('tsk."AssigneeId" = %s'))
                # params.append(current_user_id) # current_user_id должен быть передан
                print("Warning: 'мои' задачи требуют ID текущего пользователя, который здесь не доступен.")
            else:  # Поиск по имени сотрудника
                if ' ' in name_val:
                    parts = name_val.split(' ', 1)
                    where_clauses.append(sql.SQL(
                        '((emp_assignee."Name" ILIKE %s AND emp_assignee."Surname" ILIKE %s) OR (emp_assignee."Name" ILIKE %s AND emp_assignee."Surname" ILIKE %s))'
                    ))
                    params.extend([f"%{parts[0]}%", f"%{parts[1]}%", f"%{parts[1]}%", f"%{parts[0]}%"])
                else:
                    where_clauses.append(sql.SQL('(emp_assignee."Name" ILIKE %s OR emp_assignee."Surname" ILIKE %s)'))
                    params.extend([f"%{name_val}%", f"%{name_val}%"])

        if 'project' in entities:
            where_clauses.append(sql.SQL('prj."Name" ILIKE %s'))
            params.append(f"%{entities['project'][0]}%")

        if 'date' in entities:  # дедлайн
            # Нужна более умная обработка дат ("на сегодня", "на эту неделю")
            # Для примера, если дата в формате YYYY-MM-DD
            try:
                # Предположим, что NLU возвращает дату в каком-то формате, который можно преобразовать
                # Это очень упрощенно. Duckling бы дал структурированную дату.
                date_str = entities['date'][0]  # Например, "сегодня"
                if date_str == "сегодня":
                    where_clauses.append(sql.SQL('tsk."Deadline"::date = CURRENT_DATE'))
                elif date_str == "на этот месяц":
                    where_clauses.append(sql.SQL(
                        'EXTRACT(MONTH FROM tsk."Deadline") = EXTRACT(MONTH FROM CURRENT_DATE) AND EXTRACT(YEAR FROM tsk."Deadline") = EXTRACT(YEAR FROM CURRENT_DATE)'))

                # Добавить другие варианты обработки date
            except Exception as e:
                print(f"Error parsing date for task: {e}")

        if 'task_status' in entities:
            where_clauses.append(sql.SQL('tsk."Status" ILIKE %s'))
            params.append(f"%{entities['task_status'][0]}%")

        if 'task_priority' in entities:
            # Может потребоваться маппинг ("высокий" -> High)
            where_clauses.append(sql.SQL('tsk."Priority" ILIKE %s'))
            params.append(f"%{entities['task_priority'][0]}%")

        if 'task_tag' in entities:
            # Если теги в отдельной таблице, нужен JOIN
            # Пока предположим, что тег это текстовое поле в Tasks
            where_clauses.append(sql.SQL('tsk."Tags" ILIKE %s'))  # Предполагаем поле "Tags"
            params.append(f"%{entities['task_tag'][0]}%")

        if 'task_name' in entities:
            where_clauses.append(sql.SQL('tsk."Name" ILIKE %s'))
            params.append(f"%{entities['task_name'][0]}%")

        if not where_clauses:
            raise ValueError("Недостаточно критериев для поиска задач.")

        query_parts = [sql.SQL("SELECT 'TaskList',")]
        query_parts.extend(select_fields)
        query_parts.append(from_table)
        query_parts.extend(joins)

        query_parts.append(sql.SQL("WHERE ") + sql.SQL(" AND ").join(where_clauses))
        query_parts.append(sql.SQL('ORDER BY tsk."Deadline", tsk."Priority" DESC LIMIT 10'))

        final_query = sql.SQL(' ').join(query_parts)
        return final_query, params

    @staticmethod
    def _entities_to_dict(entities: list) -> dict:
        result = {}
        if not entities:  # Проверка, что entities не None и не пустой
            return result
        for entity in entities:
            entity_type = entity.get("entity")
            entity_value = entity.get("value")
            if entity_type and entity_value is not None:  # Проверка, что ключи существуют
                if entity_type not in result:
                    result[entity_type] = [entity_value]
                else:
                    result[entity_type].append(entity_value)
        return result

================================================================================

# Файл: db_response_parser.py
# Содержимое:
import textwrap
import datetime


class DbResponseParser:
    @staticmethod
    def parse_into_message(data_list: list) -> str:
        if not data_list or not data_list[0]:  # Проверка на пустой результат
            return "По вашему запросу ничего не найдено."

        # data_list это список записей (кортежей/DictRow) из БД
        # Первая запись содержит тип результата в первом элементе
        first_record = data_list[0]
        result_type = first_record[0]  # Первый столбец должен быть типом результата

        match result_type:
            case "PersonInfo":
                # Для PersonInfo, мы ожидаем одну запись в data_list, так как LIMIT 1
                return DbResponseParser.parse_person(first_record)  # Передаем одну запись
            case "BirthdayList":
                return DbResponseParser.parse_birthday_results(data_list)
            case "TaskList":
                return DbResponseParser.parse_task_results(data_list)
            # Добавьте сюда обработку других типов результатов
            case _:
                return f"Неизвестный тип результата для отображения: {result_type}"

    @staticmethod
    def parse_person(data_row: tuple) -> str:  # data_row это одна запись (кортеж/DictRow)
        # data_row[0] это 'PersonInfo', начинаем с data_row[1]
        contacts = data_row[10] if len(data_row) > 10 and data_row[10] else {}
        phone = contacts.get("phone")
        email = contacts.get("email")

        # Проверка на None перед форматированием дат
        birthday_str = data_row[4].strftime("%d.%m.%Y") if data_row[4] else "-"
        firstday_str = data_row[5].strftime("%d.%m.%Y") if data_row[5] else "-"

        return textwrap.dedent(f'''
                Нашёл первое совпадение:

                <b>{data_row[1] or ""} {data_row[2] or ""} {data_row[3] or ""}</b>
                <b>День рождения:</b> {birthday_str}
                <b>Вступил в должность:</b> {firstday_str}
                <b>Пишет на:</b> {data_row[6] or "-"}
                <b>Грейд:</b> {data_row[7] or "-"}
                <b>Сейчас работает над проектом:</b> {data_row[8] or "-"}
                <b>Состоит в отделе:</b> {data_row[9] or "-"}
                {f"<b>Почта:</b> {email}" if email else "<b>Почта:</b> -"}
                {f"<b>Номер телефона:</b> {phone}" if phone else "<b>Номер телефона:</b> -"}
            ''').strip()

    @staticmethod
    def parse_birthday_results(data_list: list) -> str:
        if not data_list:
            return "Дни рождения по вашим критериям не найдены."

        # data_list[0][0] будет 'BirthdayList', его пропускаем
        # Начинаем с data_list[0][1] для первой записи, если она одна
        # или итерируемся по data_list, если их несколько

        messages = ["<b>Найдены следующие дни рождения:</b>"]
        for row in data_list:
            # row[0] это 'BirthdayList', фактические данные начинаются с row[1]
            # surname, name, father, birthday, department_name
            surname = row[1] or ""
            name = row[2] or ""
            father = row[3] or ""  # Отчество
            birthday_date = row[4]
            department_name = row[5] or "Не указан"

            birthday_str = birthday_date.strftime("%d.%m") if isinstance(birthday_date, (
            datetime.date, datetime.datetime)) else "Дата не указана"

            person_info = f"{surname} {name} {father}".strip()
            messages.append(f"- {person_info} ({birthday_str}), Отдел: {department_name}")

        if len(messages) == 1:  # Только заголовок
            return "Дни рождения по вашим критериям не найдены."
        return "\n".join(messages)

    @staticmethod
    def parse_task_results(data_list: list) -> str:
        if not data_list:
            return "Задачи по вашим критериям не найдены."

        messages = ["<b>Найдены следующие задачи:</b>"]
        for row in data_list:
            # task_name, description, deadline, status, priority, assignee_name, assignee_surname, project_name
            task_name_val = row[1] or "Без названия"
            # description_val = row[2] or "" # Описание может быть длинным
            deadline_val = row[3].strftime("%d.%m.%Y") if isinstance(row[3], (
            datetime.date, datetime.datetime)) else "Нет дедлайна"
            status_val = row[4] or "-"
            priority_val = row[5] or "-"
            assignee_name_val = row[6] or ""
            assignee_surname_val = row[7] or ""
            project_name_val = row[8] or "Без проекта"

            assignee_full_name = f"{assignee_surname_val} {assignee_name_val}".strip()

            task_info = f"<b>{task_name_val}</b> (Проект: {project_name_val})"
            task_info += f"\n  Исполнитель: {assignee_full_name if assignee_full_name else '-'}"
            task_info += f"\n  Дедлайн: {deadline_val}, Статус: {status_val}, Приоритет: {priority_val}"
            messages.append(task_info)

        if len(messages) == 1:  # Только заголовок
            return "Задачи по вашим критериям не найдены."
        return "\n\n".join(messages)

================================================================================

# Файл: main.py
# Содержимое:
import json
import logging
import textwrap

import requests
from telegram import Update, ReplyKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
)
from ai_request_processor import AiRequestProcessor
from database_query_parser import DbQueryParser
from db_response_parser import DbResponseParser
from database import Database

DB_CONFIG = {
    "dbname": "interesich",
    "user": "cock_userr",
    "password": "ifconfigroute-3n",
    "host": "51.250.112.217",
    "port": "5432"
}

db = Database(**DB_CONFIG)

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Убедитесь, что Rasa NLU сервер запущен на этом адресе и порту
ai_request_processor = AiRequestProcessor(base_url="http://localhost:5005/model/parse")

BOT_TOKEN = '7757580544:AAHMXO0sgFFvNJMIDksbxqc9zYHrNNGo-rA'  # Ваш токен

reply_keyboard = [['/help']]
markup = ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Добро пожаловать! Я помогу вам найти информацию о сотрудниках, мероприятиях, задачах и днях рождения. Нажмите /help, чтобы узнать больше.",
        reply_markup=markup
    )


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_text = """
Вы можете спросить меня:
- "Найди Иванова Петра"
- "Какие мероприятия завтра?"
- "У кого день рождения в июне?"
- "Мои задачи на сегодня"
- "Свободен ли я завтра в 10?"

Просто напишите ваш вопрос в свободной форме!
    """
    await update.message.reply_text(
        textwrap.dedent(help_text),
        reply_markup=markup
    )


async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    logger.info(f"Получен запрос от пользователя: {text}")
    try:
        ai_response = ai_request_processor.process_query(text)
        logger.info(f"Ответ от NLU: {json.dumps(ai_response, ensure_ascii=False, indent=2)}")

        query_data = DbQueryParser.parse(ai_response)

        sql_query = None
        query_params = None

        if isinstance(query_data, tuple):
            sql_query, query_params = query_data
        else:  # Для обратной совместимости со старыми методами, возвращающими только строку
            sql_query = query_data
            query_params = None

        logger.info(f"Сформирован SQL: {sql_query} с параметрами: {query_params}")

        db_result = db.execute_query(query=sql_query, params=query_params, fetch=True)

        if not db_result:  # Проверяем, если результат пустой или None
            message = "По вашему запросу ничего не найдено."
            logger.info("БД не вернула результатов.")
        else:
            logger.info(f"Результат из БД: {db_result}")
            message = DbResponseParser.parse_into_message(db_result)

    except requests.exceptions.RequestException as e:
        logger.error(f"Ошибка при обращении к Rasa NLU API: {e}")
        message = "Извините, не удалось связаться с сервисом распознавания. Попробуйте позже."
    except ValueError as e:  # Для ошибок парсинга или отсутствия данных
        logger.warning(f"Ошибка обработки запроса: {e}")
        message = f"Не удалось обработать ваш запрос: {e}"
    except Exception as e:
        logger.exception(f"Произошла непредвиденная ошибка: {e}")  # Логируем полный стектрейс
        message = "Произошла внутренняя ошибка. Пожалуйста, попробуйте позже."

    await update.message.reply_text(message, reply_markup=markup, parse_mode=ParseMode.HTML)


def main():
    app = ApplicationBuilder().token(BOT_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(
        MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text)
    )

    logger.info("Бот запущен...")
    app.run_polling()


if __name__ == '__main__':
    main()

================================================================================

# Файл: README.md
# Содержимое:
# very-interesting-case



================================================================================

# Файл: requirements.txt
# Содержимое:
python-telegram-bot==22.1
psycopg2==2.9.10

================================================================================

# Файл: tools.py
# Содержимое:
import os


def gather_files_to_txt(root_folder, output_filename="combined_code.txt", ignore_dirs=None, ignore_extensions=None,
                        ignore_files=None):
    """
    Собирает все текстовые файлы из указанной папки и ее подпапок в один TXT-файл.
    Перед содержимым каждого файла добавляется комментарий с его относительным путем.

    :param root_folder: Корневая папка для поиска файлов.
    :param output_filename: Имя итогового TXT-файла.
    :param ignore_dirs: Список имен папок, которые нужно игнорировать (например, ['.git', '__pycache__']).
    :param ignore_extensions: Список расширений файлов, которые нужно игнорировать (например, ['.pyc', '.log']).
    :param ignore_files: Список имен файлов, которые нужно игнорировать (например, ['output.txt']).
    """
    if ignore_dirs is None:
        ignore_dirs = ['.git', '__pycache__', 'node_modules', '.venv', 'venv', 'build', 'dist', '.rasa', 'rasa']
    if ignore_extensions is None:
        # По умолчанию пытаемся взять большинство текстовых/кодовых файлов, но можно настроить
        ignore_extensions = [
            '.pyc', '.pyo', '.pyd', '.so', '.dll', '.exe', '.o', '.a', '.lib',  # скомпилированные
            '.log', '.tmp', '.bak', '.swp', '.swo',  # временные/логи
            '.DS_Store', '.Spotlight-V100', '.Trashes', 'ehthumbs.db', 'Thumbs.db',  # системные
            '.gz', '.zip', '.tar', '.rar', '.7z',  # архивы
            '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.svg', '.ico',  # изображения
            '.mp3', '.wav', '.ogg', '.flac', '.aac',  # аудио
            '.mp4', '.mov', '.avi', '.mkv', '.webm',  # видео
            '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.odt', '.ods', '.odp',  # документы
            '.tar.gz', '.tar.bz2', '.tar.xz',
            '.gitignore'# архивы
        ]
    if ignore_files is None:
        ignore_files = []

    # Добавляем сам выходной файл в список игнорируемых, чтобы он сам себя не добавил
    # если запускать скрипт из той же папки, где он будет создан
    base_output_filename = os.path.basename(output_filename)
    if base_output_filename not in ignore_files:
        ignore_files.append(base_output_filename)

    if not os.path.isdir(root_folder):
        print(f"Ошибка: Папка '{root_folder}' не найдена.")
        return

    collected_files_count = 0
    output_abs_path = os.path.abspath(os.path.join(root_folder, output_filename))
    # Если output_filename содержит путь, используем его, иначе создаем в root_folder
    if os.path.dirname(output_filename):
        output_abs_path = os.path.abspath(output_filename)
    else:
        output_abs_path = os.path.abspath(os.path.join(root_folder, output_filename))

    with open(output_abs_path, 'w', encoding='utf-8') as outfile:
        for dirpath, dirnames, filenames in os.walk(root_folder):
            # Исключаем папки из дальнейшего обхода
            dirnames[:] = [d for d in dirnames if d not in ignore_dirs]

            for filename in filenames:
                if filename in ignore_files:
                    # print(f"Пропуск файла (в списке игнорируемых): {filename}")
                    continue

                file_ext = os.path.splitext(filename)[1].lower()
                if file_ext in ignore_extensions:
                    # print(f"Пропуск файла (расширение в списке игнорируемых): {filename}")
                    continue


                full_path = os.path.join(dirpath, filename)

                # Проверяем, не является ли это сам выходной файл (на случай если он уже существует)
                if os.path.abspath(full_path) == output_abs_path:
                    continue

                relative_path = os.path.relpath(full_path, root_folder)
                # Заменяем разделители пути Windows на Unix-подобные для единообразия
                comment_path = relative_path.replace(os.sep, '/')

                try:
                    with open(full_path, 'r', encoding='utf-8', errors='ignore') as infile:
                        content = infile.read()

                    outfile.write(f"# Файл: {comment_path}\n")
                    outfile.write("# Содержимое:\n")
                    outfile.write(content)
                    outfile.write("\n\n" + "=" * 80 + "\n\n")  # Разделитель между файлами
                    collected_files_count += 1
                    print(f"Добавлен: {relative_path}")

                except Exception as e:
                    # Если файл не текстовый или проблема с кодировкой, которую errors='ignore' не решила
                    print(
                        f"Не удалось прочитать файл (возможно, бинарный или проблема с кодировкой): {relative_path} - {e}")
                    outfile.write(f"# Файл (НЕ УДАЛОСЬ ПРОЧИТАТЬ): {comment_path}\n")
                    outfile.write(f"# Ошибка: {e}\n")
                    outfile.write("\n\n" + "=" * 80 + "\n\n")

    if collected_files_count > 0:
        print(f"\nГотово! {collected_files_count} файлов собрано в '{output_abs_path}'.")
    else:
        print(
            f"\nВ папке '{root_folder}' не найдено подходящих файлов (с учетом фильтров). Файл '{output_abs_path}' создан, но пуст или содержит только ошибки чтения.")


if __name__ == "__main__":
    # --- Настройки ---
    target_folder = r"D:\wonderfulprojects\very-interesting-case"  # Текущая папка. Можно указать абсолютный или относительный путь, например "my_project_folder"
    # target_folder = "C:/Users/YourUser/Projects/MyAwesomeProject"

    output_file_name = "project_code_combined.txt"  # Имя итогового файла

    # Список папок для игнорирования (дополните при необходимости)
    custom_ignore_dirs = ['.git', '__pycache__', 'node_modules', '.venv', 'venv', 'build', 'dist', 'target', '.idea',
                          '.vscode', '.rasa']

    # Список расширений для игнорирования (дополните при необходимости)
    # Расширения, которые точно не являются текстовым кодом или конфигурацией
    custom_ignore_extensions = [
        '.gz', '.gitignore', '.gitattributes'
        # '.pyc', '.pyo', '.pyd', '.so', '.dll', '.exe', '.o', '.a', '.lib',  # скомпилированные
        # '.log', '.tmp', '.bak', '.swp', '.swo',  # временные/логи
        # '.DS_Store', '.Spotlight-V100', '.Trashes', 'ehthumbs.db', 'Thumbs.db',  # системные
        # '.gz', '.zip', '.tar', '.rar', '.7z',  # архивы
        # '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.svg', '.ico',  # изображения
        # '.mp3', '.wav', '.ogg', '.flac', '.aac',  # аудио
        # '.mp4', '.mov', '.avi', '.mkv', '.webm',  # видео
        # '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.odt', '.ods', '.odp',  # документы
        # '.jar', '.war',  # Java архивы
        # '.woff', '.woff2', '.ttf', '.eot',  # шрифты
    ]
    # Если хотите наоборот, указать только те расширения, которые включать,
    # то этот скрипт нужно будет немного доработать. Текущая логика - исключение.

    # Список конкретных файлов для игнорирования
    custom_ignore_files = [output_file_name] + ['.gitattributes', '.gitignore'] # Автоматически добавится, но можно добавить и свои
    # custom_ignore_files.append("README.md") # Например, если не хотите включать README

    # --- Запуск ---
    print(f"Сбор файлов из папки: {os.path.abspath(target_folder)}")
    print(
        f"Результат будет сохранен в: {os.path.abspath(os.path.join(target_folder, output_file_name)) if not os.path.dirname(output_file_name) else os.path.abspath(output_file_name)}")

    gather_files_to_txt(
        target_folder,
        output_file_name,
        ignore_dirs=custom_ignore_dirs,
        ignore_extensions=custom_ignore_extensions,
        ignore_files=custom_ignore_files
    )

================================================================================

